## CPU, 레지스터

CPU - 연산 장치, 제어 장치, 레지스터로 구성됨

- 연산장치 : 수칙 연산, 논리 연산 등의 수학적 연산 담당
- 제어 장치 : 메모리에서 기계어 코드를 읽고 해석한 뒤 실행
- 레지스터 : 연산을 위해 CPU가 사용하는 데이터 저장소로, 주로 메모리의 특정 주소나 특정  값을 저장

IA-32의 **레지스터**

- 범용 레지스터 8개

- EAX : 산술 계산 및 리턴 값 전달에 사용 (사용 빈도수 가장 높음)
- EBX : 범용적으로 사용 가능한 추가적인 레지스터
- ECX : 일반적으로 반복문이나 문자열 복사 시 카운트에 사용
- EDX : EAX와 비슷하게 주로 연산에 사용
- ESI : 주로 문자열, 메모리 값을 복사할 때 원본 주소를 가리킴
- EDI : 주로 문자열, 메모리 값을 복사할 때 목표 주소를 가리킴
- EBP : 스택 프레임 시작 주소(Base)가 저장됨
- ESP : 스택 프레임의 끝 지점이 저장

- 명령어 포인터

- EIP : 다음에 실행할 명령어의 주소 저장

- 세그먼트 레지스터 : 각 세그먼트의 오프셋 저장

- 플래그 레지스터 : 연산의 결과에 따라 다양한 상태 값 표시

## 메모리 구조

윈도우 메모리 구조 → 32bit의 경우 프로세스별로 4GB로 구성 (가상 메모리 사용)

할당된 4GB 중 2GB는 각 프로세스가 독립적으로 가지는 User Mode이고, 나머지 2GB는 모든 프로세스가 공유하는 Kernel Mode임 (즉, 각 프로세스가 가지는 독립된 총 메모리는 4GB이다.)

메모리 가상화를 통해 프로그램은 주소값에 신경쓰지 않고 메모리 사용이 가능하며, 오류가 발생하더라도 다른 프로세스의 메모리와 격리되어 있어 안정성이 높아짐

<img width="70%" src="https://user-images.githubusercontent.com/78725389/124773492-f76ab580-df77-11eb-81e1-e8e6e986a39f.jpeg"/>

## 스택과 힙 + 함수 호출과 리턴

stack(스택) : 후입선출 구조를 갖는 자료 구조로, **높은 주소에서 낮은 주소로 메모리가 할당**됨

heap(힙) : 힙 관리자 및 힙 구조체를 통해 관리되며, 프로그래머가 필요 시 할당 및 해제가 가능하며 **낮은 주소에서 높은 주소로 메모리가 할당**됨

<img width="70%" src="https://user-images.githubusercontent.com/78725389/124773891-52041180-df78-11eb-97b8-55e774197df3.jpeg"/>

각 함수는 별도의 스택 공간(스택 프레임)을 가져 스택 메모리를 효율적으로 관리하고, 함수의 호출 전 후의 스택의 변경을 막음

함수 호출 시 스택에 돌아올 주소를 저장하고, 스택 프레임을 생성하고

함수 종료 시 스택 프레임을 제거하고, 호출한 주소로 복귀함

이때 함수의 시작 부분에서 스택 프레임을 만들어 주는 코드를 **함수 프롤로그** / 스택 프레임을 해제하고 돌아가는 코드를 **함수 에필로그**라고 함 

- 함수 프롤로그

<img width="70%" src="https://user-images.githubusercontent.com/78725389/124773898-53cdd500-df78-11eb-9adb-74d29965f82b.jpeg"/>

- 함수 에필로그

<img width="70%" src="https://user-images.githubusercontent.com/78725389/124773909-54ff0200-df78-11eb-9ae6-7f6ca6bf9a70.jpeg"/>

이때 인자 값을 전달하고 스택을 정리하는 과정에서 함수를 호출하는 쪽과 호출당하는 함수 사이의 혼란 방지를 위해 함수 호출 과정에 일정한 규약(**함수 호출 규약**) 존재

- 함수 호출 규약

    - _cdecl : 인자값 전달은 오른쪽부터(a,b의 경우 b부터 push), 스택 정리는 caller(Add esp, n)

    - _stdcall : 인자값 전달은 오른쪽부터, 스택 정리는 callee(ret n) - 함수 내부에서 리턴과 동시에 수행

    - _fastcall : 인자값 전달은 레지스터 + 스택(인자 값을 레지스터에 옮기지 않고 바로 레지스터를 통해 값 전달), 속도가 빠르나 경우에 따라 코드가 길어지기도 함

## 어셈블리어 기초

- PUSH : 스택에 값을 저장 (push 이후 스택이 4바이트 커져 ESP 레지스터는 4byte 감소)
- POP : 스택의 끝에 저장된 값 가져옴 (pop 이후 스택이 4바이트 작아져 ESP 레지스터는 4byte 증가)
- MOV : 지정한 값을 지정한 곳에 넣어줌
- LEA : 저장된 주소를 지정한 곳에 저장
- INC : 값을 1 증가시킴
- DEC : 값을 1 감소시킴
- ADD : 두 피연산자의 덧셈 연산을 수행
- SUB : 두 피연산자의 뺄셈 연산을 수행
- CALL : 함수 호출 (스택에 리턴 주소를 push한 후, 함수가 끝나면 바로 뒤의 주소값으로 점프함)
- RET : 함수 내부에서 원래 코드로 돌아옴 (POP EIP 수행)
- NOP : 아무 동작도 하지 않음 (0x90) - 단순히 주소를 채우거나, 주소 값을 알지 못하는 상황에서 자주 사용
- XOR, OR, AND, SHR, SHL - 각각에 해당하는 비트 연산 수행

    (XOR : 각 비트를 비교하여 값이 같으면 0, 다르면 1로 계산

     OR : 두 비트 중 하나라도 1이면 1, 아니면 0으로 계산

     AND : 두 비트 모두 1이면 1, 아니면 0으로 계산

     SHR : 각 비트를 오른쪽으로 쉬프트 연산 (벗어난 비트 CF 플래그 레지스터에 저장)

     SHL : 각 비트를 왼쪽으로 쉬프트 연산 (벗어난 비트 CF 플래그 레지스터에 저장))

- CMP, JMP, JE, ... : 비교, 점프 수행

## 윈도우 실행 파일 구조

실행 파일 → 코드 / 리소스 / 사용하는 DLL 함수 등의 정보를 가짐

- PE 파일이란?

윈도우 실행 파일 = PE 파일 (Portable Executable)

다양한 정보를 포함한 커다란 구조체들로 이루어져 있으며, 내부적으로 수많은 테이블과 멤버를 가짐

PE 파일의 종류

- EXE : 실행 파일
- SCR : 실행 파일 (화면 보호기) → 화면보호기를 이용한 악성코드가 많이 생성됨
- DLL : 라이브러리
- OCX : 라이브러리 (Active X)
- SYS :  시스템 드라이버
- OBJ : 오브젝트 파일

PE 파일의 구조는 파일로 존재할 때와 메모리에 로드 된 후에 달라짐

메모리에 로드될 때 고정 주소 대신 가상 주소를 사용하는데, 이는 PE 파일이 메모리에 로드될 때 한 주소에 고정적으로 로딩되는 것이 아니기 때문

또한 File Alignment(처리상의 효율성을 위해 특정 단위로 간격을 맞추는 것) 값보다 Section Alignment 값이 더 크기 때문에 메모리에 로드된 후 사이즈가 조금 더 커지고, 남는 공간은 모두 널바이트로 채워짐 (내부 조각? 외부조각? 알아보기)
